# 第5章 软件构建中的设计 / Design in Construction

## 5.1 设计中的挑战 / Design Challenges

### 设计是一个险恶的问题 / Design Is a Wicked Problem

险恶的问题就是那种只有通过解决或部分解决才能被明确的问题。这个看似矛盾的定义其实是在暗示
说，你必须首先把这个问题“解决”一遍以便能够明确地定义它，然后再次解决该问题，从而形成一个
可行的方案。

### 设计是个了无章法的过程 / Design Is a Sloppy Process

软件设计的成功应该是组织良好、干净利落的，然而形成这个设计的过程却并非如此清爽。

说设计了无章法，是因为在此过程中你会采取很多错误的步骤，多次误入歧途——你会犯很多的错误。
事实上，犯错正是设计的关键所在——在设计阶段犯错并加以改正，其代价要比在编码后才发现同样的
错误并彻底修改低得多。

### 设计是自然而然形成的 / Design Is Emergent

把设计的这些特征综合归纳起来，我们可以说设计是“自然而然形成的”。设计不是在谁的头脑中直接
跳出来的。它是在不断的设计评估、非正式讨论、写试验代码以及修改试验代码中演化和完善的。

## 5.2 关键的设计概念 / Key Design Concepts

### 软件的首要技术使命：管理复杂度 / Software's Primary Techinical Imperative: Managing Complexity

Brooks认为，两类不同的问题导致软件开发变得困难——本质的问题和偶然的问题。本质的属性是一件
事物必须具备、如果不具备就不再是该事物的属性。偶然的属性则是指一件事物碰巧具有的属性，有
没有这些属性都并不影响这件事物本身。

Brooks观察到，软件开发中大部分的偶然性难题在很久以前就已得到解决了，在软件开发剩下的那些
本质性困难上的进展将会变得相对缓慢。究其原因，是因为从本质上说软件开发就是不断地去发掘错
综复杂、相互连接的整套概念的所有细节。其本质性的困难来自很多方面：必须去面对复杂、无序的
现实世界；精确而完整地识别出各种依赖关系与例外情况；设计出完全正确而不是大致正确的解决方
案；诸如此类。

## 5.3 设计构造块：启发式方法 / Design Building Blocks: Heuristics

### 当继承能简化设计时就继承 / Inherit-When Inheritance Simplifies the Design

编程语言如果能支持像Open()或Close()这样在运行期间才能确定所针对的对象的实际类型的操作，
这种能力叫做“多态/polymorphism”。

继承是面向对象编程中最强大的工具之一。如果使用得当，它能带来极大的益处，然而如果使用不当，
它也有极大的弊端。

### 隐藏秘密（信息隐藏）/ Hide Secrets (Information Hiding)

信息隐藏是结构化程序设计与面向对象设计的基础之一。结构化设计里面的“黑盒子”概念就是来源于
信息隐藏。在面向对象设计中，它又引出了封装和模块化的概念，并与抽象的概念紧密相关。

信息隐藏是减少重复工作的强大技术。它在不断增长的、大量变化的环境中尤其有用。

设计类的接口与设计其他环节一样，都是一个迭代的过程。如果你第一次没有得到合适的接口，那么
就多试几次，直到设计稳定下来。如果设计仍不稳定，拿你就需要换种方法再尝试。

### 查阅常用的设计模式 / Look for Common Design Patterns

设计模式精炼了众多现成的解决方案，可用于解决很多软件开发中最常见的问题。有些软件问题要求
全新的解决方案，但是大多数问题都和过去遇到过的问题类似，因此可以使用类似的解决方案加以解
决。

### 使用启发式方法的原则 / Guidelines for Using Heuristics

软件中的设计方法可以从其他领域中的设计方法借鉴许多东西。最早有关解决问题的探索方法的著作
之一便是G·波利亚写的《怎样解题》。

最有效的原则之一就是不要卡在单一的方法上。如果用UML画设计图不可行，那么就直接用英语来写。
写段简短的测试程序。尝试一种截然不同的方法。想出一种蛮力解决方案。用铅笔画出轮廓和草图来
指导思想。如果这些方法都不行，那么就先离开这个问题。可以去散散步，或者去想一想其他的事情，
然后再回来重新面对这个问题。如果你尽了全力还没能取得突破，那么暂时不要去想它反而会比穷思
苦想的效果要好。

你无须马上解决整个设计难题。一旦被卡住了，那么请记住回过头来时有一处地方需要做决策，但眼
下你还没有足够的信息来解决这个问题。你可以让那些问题留在未解决状态，等到你拥有更多信息之
后再去做。

# 第7章 高质量的子程序 / High-Quality Routines

子程序（routine）是为实现一个特定的目的而编写的一个可被调用的方法（method）或过程（procedure），
例如C++中的函数(function)，Java中的方法（method），或Microsoft Visual Basic中的函数
过程（function procedure）或子过程（Sub procedure）。

## 7.1 创建子程序的正当理由 / Valid Reasons to Create a Routine

- 如果没有子程序的抽象能力，我们的智力将根本无法管理复杂的程序。

## 7.2 在子程序层上设计 / Design at the Routine Level

- 内聚性（cohesion）的概念是由 Wayne Stevens, Glenford Myers 和 Larry Constantine在
1974年发表的一篇论文中提出来的。其他一些更为现代的概念，如抽象和封装等，通常在类这一层次
的设计中更为适用，但内聚性的概念仍然存在，而且在单个子程序这一层次上，仍是设计时常用的启
发式方法。
- 功能的内聚性（functional cohesion）是最强也是最好的一种内聚性，也就是说让一个子程序仅
执行一项操作。

## 7.3 好的子程序名字 / Good Routine Names

- 子程序的名字应当描述其所有的输出结果以及副作用。
- 研究表明，变量名的最佳长度是9到15个字符，而子程序名的长短要视该名字是否清晰易懂而定。
- 给过程起名时使用语气强烈的动词加宾语的形式，在面向语言中，你不用在过程名中加入对象的名
词（宾语），因为对象本身已经包含在调用语句中了。

## 7.5 如何使用子程序参数 / How to Use Routine Parameters

- 把子程序的参数个数限制在大约7个以内。心理学研究发现，通常人类很难同时记住超过7个单位的
信息。

## 7.6 使用函数时要特别考虑的问题 / Special Considerations in the Use of Functions

- 函数是指有返回值的子程序；过程是指没有返回值的子程序。在C++中，通常把所有子程序都称为
函数，然而，那些返回值类型为void的函数在语义上其实就是过程。
- 如果一个子程序的主要用途就是返回由其名字所指明的返回值，那么就应该使用函数，否则就应该
使用过程。

## 7.7 宏子程序和内联子程序 / Macro Routines and Inline Routines

- 节制使用inline子程序：
  - inline子程序违反了封装原则，因为C++要求其实现在头文件里，将实现细节暴露给使用者；
  - 会增加整体代码的长度；
  - 为性能原因使用inline需要通过剖测（profile）代码衡量性能上的改进看是否值得。

# 第8章 防御式编程 / Defensive Programming

防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错
误数据。

## 8.1 保护程序免遭非法输入数据的破坏 / Protecting Your Program from Invalid Inputs

- 用使用迭代设计、编码前先写伪码、写代码前先写测试用例、低层设计检查等活动，都有助于防止
引入错误。

## 8.2 断言 / Assert

- 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。错误处理通常用来
检查有害的输入数据，而断言是用于检查代码中的bug。

## 8.4 异常 / Exceptions

- 了解所用函数库可能抛出的异常。未能捕获由函数库抛出的异常将会导致程序崩溃，就如同未能捕
获未能由自己代码抛出的异常一样。
- 自始自终考虑各种各样的错误处理机制：在局部处理错误、使用错误码来传递错误、在日志文件中
记录调试信息、关闭系统或其他的一些方式。仅仅因为编程语言提供了异常处理机制而使用异常，是
典型的“为用而用”。
