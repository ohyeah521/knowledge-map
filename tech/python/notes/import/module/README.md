## 模块

模块是Python里最高级别的程序组织单元，它将程序代码和数据封装起来以便重用。每一个文件都是
一个模块，并且模块导入其他模块之后就可以使用导入模块定义的变量名。在模块导入时，模块文件
的全局作用域变成了模块对象的命名空间。

一个Python程序包括了多个含有Python语句的文本文件，程序由一个主体的、顶层文件，配合零个
或多个支持文件。顶层文件（又称为脚本）包含了程序的主要控制流程，模块文件就是工具库，前者
使用后者定义的工具，后者可能还使用其他模块定义的工具。

### 1.import如何工作

Python的`import`语句并不同于C里的`#include`，因为它并不是把一个文件文本插入到另一个文件，
而是一种运行时运算，程序第一次导入指定文件时，会执行三个步骤：

- 搜索：找到模块文件。
  - Python使用标准模块搜索路径来找到对应模块，因此不需要指定路径和后缀名。
- 编译：编译成位码（需要时）。
  - Python会检查文件的时间戳，如果字节码文件比源代码旧那么程序运行时重新编译成字节码；
  - Python在搜索路径上只发现字节码而没有源代码时就会直接加载字节码；
  - 只有被导入的文件才会留下字节码文件.pyc，用来提高之后导入的速度；
  - 顶层文件通常是设计成直接执行，而不是被导入的，但一个文件即作为顶层文件又能被导入也是可能的。
- 运行：执行模块代码来创建其所定义的对象。

Python把载入的模块存储到`sys.modules`的表中，在导入操作之初便检查该表，如果模块不存在则
执行上述三个步骤并存储到该表，在下一次导入时便可以直接提取内存中已经加载的模块对象。

### 2.模块搜索路径

Python的模块搜索路径（sys.path）是由四个组件组合而成：

- 程序的主目录：当你运行一个程序的时候，这个入口是包含程序的顶层脚本文件的目录；当在交互模式下工作时，这个入口时当前工作目录。
- PYTHONPATH目录（如果已经进行了设置）：Python会从左至右搜索PYTHONPATH环境变量设置中列出的所有目录，通常在导入文件处于不同目录时需要。
  - Windows上通过控制面板来设置名称为“PYTHONPATH”的环境变量；
- 标准库目录：Python会自动搜索标准库模块的安装目录。
- 任何.pth文件内容（如果存在的话）：Python会把文件每行所列的目录从头至尾添加到模块搜索路径列表的最后，类似于PYTHONPATH。
  - .pth文件通常放置在Python安装目录的顶层或者标准库所在位置的sitepackages子目录。

搜索路径的配置可能随着平台及Python版本不同，如果要查看模块搜索路径的实际配置，可以通过打
印内置的`sys.path`列表来查看。它是在程序启动时进行配置，自动将顶级文件主目录、任何PYTHONPATH、
已经创建的任何.pth文件路径的内容以及标准库目录合并。

只有在跨目录进行导入时才需要模块搜索路径的设置。

*文件名后缀是可以从import语句中省略的，Python会选择在搜索路径中第一个符合导入文件名的文
件，它既可以是源代码文件x.py、字节码文件x.pyc、目录x或者其他编译扩展模块。*

## 编写模块代码

### 1.模块的创建

任何以.py为后缀名的Python文件都被自动认为是Python模块。当一个模块被导入时，Python会把内
部模块名映射到外部文件名，也就是通过把模块搜索路径中的目录路径加在前面，而.py或其他后缀名
添加在后边。

### 2.模块的使用

- `import x`语句：读取整个模块，并用x来代表整个模块对象，具体属性需要通过x.y来引用。
- `from x import y`语句：将变量名复制到令一个作用域，直接通过y引用对应变量。
  - from语句会在导入中创建新变量，这些变量初始化时引用了导入文件中的同名对象；
  - 如上语句相当于先`import x`再`y = x.y`。
- `from x import *`语句：取得x模块顶层所有赋了值的变量名的拷贝。

import和from是可执行的语句，而不是编译期间的声明，它们可以嵌套在if测试、函数def中，直到
执行程序时才会进行解析。

使用`from x import *`导入变量可能破坏命名空间，即其中有变量名与当前作用域中变量同名，因
此通常限制在每个文件中只使用一次，多数from语句用于明确列出想要的变量，而简单的模块倾向于
使用import。

### 3.模块命名空间

模块就是命名空间，即变量名创建的场所，存在于模块之内的变量名就是模块对象的属性，它们是以
字典的形式储存的，可以通过`list(module.__dict__.keys())`来打印所有属性。

文件导入后需要点号运算符放读取变量名，点号运算可用于任何具有属性的对象：模块、类、C扩展类型等。

### 4.重载模块

模块程序代码默认只在导入时执行一次，要强制模块代码重新载入并运行，得调用reload内置函数，
这里面的过程如下：

- 在模块第一次导入（通过import或者from语句）时，该模块被加载并执行；
- 之后的导入只会使用已经加载的模块对象，而不会重载或执行文件的代码；
- reload函数会强制已加载的模块代码重新执行。

在重载之前模块一定是已经预先成功导入的。reload是Python的内置函数不是语句，因此在语法上
小有不同：

```
import module
...use module.attributes...

from imp improt reload
reload(module)
...use module.attributes...
```

## 模块包

Python代码的目录就称为包，这类导入称为包导入。包导入是把计算机上的目录变成另一个Python命
名空间，而属性则对应于目录所包含的子目录和模块文件。

### 1.包导入基础

如下的语句表明了机器上有个目录dir1，而dir1里有子目录dir2，dir2内包含一个名为mod.py的模
块文件。同时该导入意味着dir1位于某个容器目录dir0中，这个`dir0`目录可以在Python模块搜索
路径中找到（或者它本身就是顶层文件的主目录）。

```
import dir1.dir2.mod
from dir1.dir2.mod import x
```

在使用包导入时，必须遵守一条约束：包导入语句的路径中每个目录内必须有__init__.py文件，否
则包导入会失败。如上的代码目录结构解释如下：

- dir1和dir2中必须都包含一个__init__.py文件。__init__.py文件扮演了包初始化、替目录产生命名空间以及实现`from *`行为的角色：
  - Python首次导入某个目录时会自动执行该目录下__init__.py文件中所有程序的代码。
  - 脚本内的目录路径，在导入后会变成真实的嵌套对象路径。
  - 在__init__.py里使用__all__列表来定义目录以`from*`语句形式导入时导出的变量名。
- dir0时容器，不需要__init__.py文件，如果有的话，它也会被忽略。
  - 如果直接执行某个程序，__init__.py不会被调用。
- dir0必须列在模块搜索路径上（该目录是主目录，或者列在PYTHONPATH中）。

*注：import语句中的目录路径只能是以点号间隔的变量。*

### 2.包相对导入

包自身内部的导入称为相对导入，它们的语法与Python版本有关。

|语法|Python 2.6|Python 2.7|Python 3.0|
|-|-|-|-|
|常规导入语句|隐式地搜索包目录（相对搜索），再绝对搜索。|绝对搜索。|需要显示指定相对导入语法，默认执行绝对导入（绝对搜索）。|
|带.号的from语句|执行相对搜索。||执行相对搜索|
|improt语句|先相对再绝对。|绝对搜索。|先相对再绝对。|


```
from . improt spacm # 在Python3.0, 2.6中，均执行相对搜索。
from .. improt spacm # 导入当前包上层目录的spacm。
```

尽管绝对导入允许我们略过包模块，它们仍然依赖于sys.path上的其他部分，因此并不会略过当前工
作目录（CWD），比如：

```
C:\test\pkg\spam.py
C:\test\pkg\eggs.py
C:\test\pkg\__init__.py
```

在spam.py里面使用import eggs语句不会成功，因为当前spam.py和eggs.py都处于同一个包内，
会执行绝对搜索（不会看到pkg目录下的eggs.py），但如果工作目录在pkg下面是可以的。

- 测试1：在`c:\test`目录进入python命令行，执行`import pkg.spam`会提示错误。
- 测试2：在`c:\test\pkg`目录进入python命令行，执行`import spam`会正常工作。

## 高级模块话题
