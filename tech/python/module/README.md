# 模块

模块是Python里最高级别的程序组织单元，它将程序代码和数据封装起来以便重用。每一个文件都是
一个模块，并且模块导入其他模块之后就可以使用导入模块定义的变量名。在模块导入时，模块文件
的全局作用域变成了模块对象的命名空间（即导入给予了对模块的全局作用域中的变量名的读取权）。

一个Python程序包括了多个含有Python语句的文本文件，程序由一个主体的、顶层文件，配合零个
或多个支持文件。顶层文件（又称为脚本）包含了程序的主要控制流程，模块文件就是工具库，前者
使用后者定义的工具，后者可能还使用其他模块定义的工具。

模块术语的变化：

- 模块文件常常作为Python写成的程序。也就是说，一个程序是由一系列预编写好的语句构成，保存在
文件中，从而可以反复执行。
- 可以直接运行的模块文件往往也叫做脚本（一个顶层程序文件的非正式说法）。
- 有些人将“模块”这个说法应用于被另一个文件所导入的文件。

## import如何工作

`import x`中的模块名x起到两个作用：首先，识别加载的外部文档，也会变成赋值给被载入模块的
变量。其次，x定义的对象也会在执行时创建。Python的`import`语句并不同于C里的`#include`，
因为它并不是把一个文件文本插入到另一个文件，而是一种运行时运算，程序第一次导入指定文件时，
会执行三个步骤：*(注：使导入指定文件<模块>，而非目录<包>)*

- 搜索：找到模块文件。
  - Python使用标准模块搜索路径来找到对应模块，因此不需要指定路径和后缀名。
- 编译：编译成位码（需要时）。
  - Python会检查文件的时间戳，如果字节码文件比源代码旧那么程序运行时重新编译成字节码；
  - Python在搜索路径上只发现字节码而没有源代码时就会直接加载字节码；
  - 只有被导入的文件才会留下字节码文件.pyc，用来提高之后导入的速度；
  - 顶层文件通常是设计成直接执行，而不是被导入的，但一个文件即作为顶层文件又能被导入也是
  可能的。
- 运行：执行模块代码来创建其所定义的对象。

Python把载入的模块存储到`sys.modules`的表中，在导入操作之初便检查该表，如果模块不存在则
执行上述三个步骤并存储到该表，在下一次导入时便可以直接提取内存中已经加载的模块对象。

## 模块搜索路径

Python的模块搜索路径（sys.path）是由四个组件组合而成：

- 程序的主目录：当你运行一个程序的时候，这个入口是包含程序的顶层脚本文件的目录；当在交互
模式下工作时，这个入口时当前工作目录。
- PYTHONPATH目录（如果已经进行了设置）：Python会从左至右搜索PYTHONPATH环境变量设置中列
出的所有目录，通常在导入文件处于不同目录时需要。
  - Windows上通过控制面板来设置名称为“PYTHONPATH”的环境变量；
- 标准库目录：Python会自动搜索标准库模块的安装目录。
- 任何.pth文件内容（如果存在的话）：Python会把文件每行所列的目录从头至尾添加到模块搜索路
径列表的最后，类似于PYTHONPATH。
  - .pth文件通常放置在Python安装目录的顶层或者标准库所在位置的sitepackages子目录。

搜索路径的配置可能随着平台及Python版本不同，如果要查看模块搜索路径的实际配置，可以通过打
印内置的`sys.path`列表来查看。它是在程序启动时进行配置，自动将顶级文件主目录、任何
PYTHONPATH、已经创建的任何.pth文件路径的内容以及标准库目录合并。

只有在跨目录进行导入时才需要模块搜索路径的设置。

如上第一条搜索规则决定了在 benchmark.py 中导入 strategy模块时不能简单的如C/C++一样使用
`import strategy`而是需要从工作目录开始搜索，即使用`import src.strategies.strategy
as strategy`才行。

```
C:.
│  line_parser.py
│
├─src
│  │  parser.py
│  │
│  ├─strategies
│  │  │  benchmark.py
│  │  │  maxrlc.py
│  │  │  strategy.py
```

*文件名后缀是可以从import语句中省略的，Python会选择在搜索路径中第一个符合导入文件名的文
件，它既可以是源代码文件x.py、字节码文件x.pyc、目录x或者其他编译扩展模块。*

# 编写模块代码

## 模块的创建

任何以.py为后缀名的Python文件都被自动认为是Python模块。当一个模块被导入时，Python会把内
部模块名映射到外部文件名，也就是通过把模块搜索路径中的目录路径加在前面，而.py或其他后缀名
添加在后边。

## 模块的使用

- `import x`语句：读取整个模块，并用x来代表整个模块对象，具体属性需要通过x.y来引用。
- `from x import y`语句：将变量名复制到另一个作用域，直接通过y引用对应变量。
  - from语句会在导入中创建新变量，这些变量初始化时引用了导入文件中的同名对象；
  - 如上语句相当于先`import x`再`y = x.y`。
- `from x import *`语句：取得x模块顶层所有赋了值的变量名的拷贝。

import和from是可执行的语句，而不是编译期间的声明，它们可以嵌套在if测试、函数def中，直到
执行程序时才会进行解析。

使用`from x import *`导入变量可能破坏命名空间，即其中有变量名与当前作用域中变量同名，因
此通常限制在每个文件中只使用一次，多数from语句用于明确列出想要的变量，而简单的模块倾向于
使用import。

## 模块命名空间

模块就是命名空间，即变量名创建的场所，存在于模块之内的变量名就是模块对象的属性，它们是以
字典的形式储存的，可以通过`list(module.__dict__.keys())`来打印所有属性。

文件导入后需要点号运算符放读取变量名，点号运算可用于任何具有属性的对象：模块、类、C扩展类型等。

## 重载模块

模块程序代码默认只在导入时执行一次，要强制模块代码重新载入并运行，得调用reload内置函数，
这里面的过程如下：

- 在模块第一次导入（通过import或者from语句）时，该模块被加载并执行；
- 之后的导入只会使用已经加载的模块对象，而不会重载或执行文件的代码；
- reload函数会强制已加载的模块代码重新执行。

在重载之前模块一定是已经预先成功导入的。reload是Python的内置函数不是语句，因此在语法上
小有不同：

```
import module
...use module.attributes...

from imp improt reload
reload(module)
...use module.attributes...
```
